{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Indice","text":"<p># Apuntes sobre Java</p>"},{"location":"index.html#indice","title":"Indice","text":"<ul> <li>Excepciones</li> <li>Herencia</li> <li>Clases abstractas</li> <li>Sobreescritura de m\u00e9todos</li> <li>Covarianza</li> <li>Interfaces</li> <li>Clases an\u00f3nimas</li> <li>Genericidad</li> <li>Reflexi\u00f3n</li> </ul>"},{"location":"java/clases_abstractas.html","title":"Clases abstractas","text":""},{"location":"java/clases_abstractas.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/clases_abstractas.html#contenido","title":"Contenido","text":"<ul> <li>Que son las clases abstractas?</li> <li>Herencia de clases abstractas</li> <li>Observaciones importantes sobre las clases abstractas</li> </ul>"},{"location":"java/clases_abstractas.html#que-son-las-clases-abstractas","title":"Que son las clases abstractas?","text":"<p>En Java, una clase abstracta es una clase que no se puede instanciar. La clase abstracta puede contener m\u00e9todos abstractos y m\u00e9todos concretos (implementados). Los m\u00e9todos abstractos son m\u00e9todos que no tienen implementaci\u00f3n. Los m\u00e9todos concretos son m\u00e9todos que tienen implementaci\u00f3n. Las clases abstractas se definen con la palabra clave <code>abstract</code>.</p> <pre><code>public abstract class Figura {\n    public abstract double area();\n    public abstract double perimetro();\n}\n</code></pre> <p>Una clase abstracta puede tener atributos, m\u00e9todos abstractos y m\u00e9todos concretos. Los m\u00e9todos abstractos se declaran con la palabra clave <code>abstract</code> y no tienen implementaci\u00f3n. Deben ser implementados en las subclases que heredan de la clase abstracta. </p> <p>Las clases abstractas se utilizan como plantilla para implementar subclases concretas que deben implementar todos los m\u00e9todos abstractos. </p> <p></p>"},{"location":"java/clases_abstractas.html#herencia-de-clases-abstractas","title":"Herencia de clases abstractas","text":"<p>Una subclase que hereda de una clase abstracta debe implementar todos los m\u00e9todos abstractos de la clase abstracta. </p> <p><pre><code>public abstract class Figura {\n    public abstract double calcularArea();\n}\n\npublic class Circulo extends Figura {\n    private double radio;\n\n    public Circulo(double radio) {\n        this.radio = radio;\n    }\n\n    @Override\n    public double calcularArea() {\n        return Math.PI * radio * radio;\n    }\n}\n</code></pre> Si la subclase no implementa todos los m\u00e9todos abstractos, la subclase debe declararse como abstracta.</p> <pre><code>public abstract class Figura {\n    public abstract double calcularArea();\n}\n\npublic abstract class Circulo extends Figura {\n    private double radio;\n\n    public Circulo(double radio) {\n        this.radio = radio;\n    }\n\n    public abstract double calcularPerimetro();\n}\n\npublic class CirculoConcreto extends Circulo {\n    public CirculoConcreto(double radio) {\n        super(radio);\n    }\n\n    @Override\n    public double calcularArea() {\n        return Math.PI * radio * radio;\n    }\n\n    @Override\n    public double calcularPerimetro() {\n        return 2 * Math.PI * radio;\n    }\n}\n</code></pre>"},{"location":"java/clases_abstractas.html#observaciones-importantes-sobre-las-clases-abstractas","title":"Observaciones importantes sobre las clases abstractas","text":"<ul> <li>Una clase abstracta no se puede instanciar.</li> <li>Una clase abstracta puede tener constructores.</li> <li>Una clase abstracta puede tener atributos.</li> <li>Una clase abstracta puede tener m\u00e9todos est\u00e1ticos.</li> <li>Si una subclase no implementa todos los m\u00e9todos abstractos de la clase abstracta, la subclase debe declararse como abstracta.</li> </ul>"},{"location":"java/clases_anonimas.html","title":"Clases an\u00f3nimas","text":""},{"location":"java/clases_anonimas.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/clases_anonimas.html#contenido","title":"Contenido","text":"<ul> <li>Que son las clases an\u00f3nimas ?</li> <li>Ejemplos<ul> <li>Ejemplo con clase abstracta</li> <li>Ejemplo con interfaz</li> </ul> </li> <li>Reglas</li> </ul>"},{"location":"java/clases_anonimas.html#que-son-las-clases-anonimas","title":"Que son las clases an\u00f3nimas ?","text":"<p>Las clases an\u00f3nimas en Java son clases que no tienen nombre. Se utilizan cuando necesitamos crear una clase que se extienda de una clase o implemente una interfaz, pero que no necesitamos usar en ning\u00fan otro lugar. Las clases an\u00f3nimas se implementan en el lugar donde se necesitan.</p> <p>Se puede crear una clase an\u00f3nima que extienda una clase o implemente una interfaz, en los dos casos la clase an\u00f3nima debe implementar los m\u00e9todos de la interfaz o de la clase abstracta.</p>"},{"location":"java/clases_anonimas.html#ejemplos","title":"Ejemplos","text":""},{"location":"java/clases_anonimas.html#ejemplo-con-clase-abstracta","title":"Ejemplo con clase abstracta","text":"<pre><code>abstract class Person {\n    abstract void eat();\n}\n\nclass Test {\n    public static void main(String args[]) {\n        Person p = new Person() {\n            @Override\n            void eat() {\n                System.out.println(\"nice fruits\");\n            }\n        };\n\n        p.eat();\n    }\n}\n</code></pre>"},{"location":"java/clases_anonimas.html#ejemplo-con-interfaz","title":"Ejemplo con interfaz","text":"<pre><code>interface Eatable {\n    void eat();\n}\n\nclass Test {\n    public static void main(String args[]) {\n        Eatable e = new Eatable() {\n            @Override\n            public void eat() {\n                System.out.println(\"nice fruits\");\n            }\n        };\n\n        e.eat();\n    }\n}\n</code></pre>"},{"location":"java/clases_anonimas.html#reglas","title":"Reglas","text":"<ul> <li>Se usan para crear un \u00fanico objeto.</li> <li>Se usan para implementar una interfaz o extender una clase abstracta.</li> <li>Una clase an\u00f3nima solo puede implementar una interfaz.</li> <li>Una clase an\u00f3nima solo puede extender una clase abstracta o implementar una interfaz, pero no ambas.</li> <li>Una clase an\u00f3nima no puede tener constructores.</li> <li>Una clase an\u00f3nima tiene acceso a los miembros de su clase externa.</li> <li>Una clase an\u00f3nima no puede acceder a ninguna variable local en su m\u00e9todo que no sea final.</li> </ul>"},{"location":"java/covarianza.html","title":"Covarianza en Java","text":""},{"location":"java/covarianza.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/covarianza.html#contenido","title":"Contenido","text":"<ul> <li>Que es la covarianza ?</li> <li>Ejemplo</li> </ul>"},{"location":"java/covarianza.html#que-es-la-covarianza","title":"Que es la covarianza ?","text":"<p>La covarianza es un concepto importante en Java que se refiere la capacidad de tratar un objeto de un tipo derivado (subtipo) como si fuera del tipo base(clase padre). La covarianza permite una gran flexibilidad en la creaci\u00f3n de estructuras de datos que deben ser capaces de manejar diferentes tipos de datos. En Java se aplica principalmente en las listas.</p>"},{"location":"java/covarianza.html#ejemplo","title":"Ejemplo","text":"<p>Suponemos que tenemos una clase padre llamada <code>Animal</code> que tiene el m\u00e9todo <code>makeSound()</code> y tres clases hijas <code>Dog</code>,<code>Cat</code> y <code>Cow</code> que heredan de la clase padre <code>Animal</code> y sobrescriben el m\u00e9todo <code>makeSound()</code>.</p> <pre><code>public class Animal {\n    public void makeSound() {\n        System.out.println(\"Animal sound\");\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof\");\n    }\n}\n\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\npublic class Cow extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Moo\");\n    }\n}\n</code></pre> <p>Usando la covarianza podemos crear una lista de objetos de tipo <code>Animal</code> y agregar objetos de tipo <code>Dog</code>,<code>Cat</code> y <code>Cow</code> a la lista.</p> <pre><code>List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();\nanimals.add(new Dog());\nanimals.add(new Cat());\nanimals.add(new Cow());\n</code></pre> <p>Ahora podemos iterar sobre la lista y llamar al m\u00e9todo <code>makeSound()</code> de cada objeto.</p> <pre><code>for (Animal animal : animals) {\n    animal.makeSound();\n}\n</code></pre>"},{"location":"java/excepciones.html","title":"Excepciones","text":""},{"location":"java/excepciones.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/excepciones.html#contenido","title":"Contenido","text":"<ul> <li>Que es una excepcion?</li> <li>Jerarqu\u00eda de excepciones</li> <li>Tipos de excepciones<ul> <li>Excepciones comprobadas o checked exceptions</li> <li>Excepciones no comprobadas o unchecked exceptions o <code>Runtime exceptions</code></li> </ul> </li> <li>Excepciones m\u00e1s comunes</li> <li>Manejo de excepciones<ul> <li>Bloque try-catch</li> <li>Lanazamiento de excepciones</li> </ul> </li> <li>Excepciones definidas por el usuario</li> </ul>"},{"location":"java/excepciones.html#que-es-una-excepcion","title":"Que es una excepcion?","text":"<p>Una excepci\u00f3n en Java es un evento inesperado que puede interrumpir el flujo de la ejecuci\u00f3n. Se usan las excepciones para manejar errores y otros eventos que pueden ocurrir durante la ejecuci\u00f3n de un programa.</p>"},{"location":"java/excepciones.html#jerarquia-de-excepciones","title":"Jerarqu\u00eda de excepciones","text":"<p>La clase base de todas las excepciones es la clase Throwable. Esta clase tiene dos subclases directas: Error y Exception. La clase Error representa errores que no se pueden recuperar, como por ejemplo un error de memoria. La clase Exception representa errores que se pueden recuperar, como por ejemplo un error de divisi\u00f3n por cero. La clase Exception tiene varias subclases, que representan diferentes tipos de excepciones. Por ejemplo, la clase ArithmeticException representa una excepci\u00f3n de divisi\u00f3n por cero.</p>"},{"location":"java/excepciones.html#tipos-de-excepciones","title":"Tipos de excepciones","text":"<p>Las excepciones se dividen en dos tipos:</p>"},{"location":"java/excepciones.html#excepciones-comprobadas-o-checked-exceptions","title":"Excepciones comprobadas o checked exceptions","text":"<p>Excepci\u00f3n que ocurre en tiempo de compilaci\u00f3n. El compilador obliga a que se capture o se lance la excepci\u00f3n. </p> <p>Ejemplos:  - FileNotFoundException - IOException - SQLException</p>"},{"location":"java/excepciones.html#excepciones-no-comprobadas-o-unchecked-exceptions-o-runtime-exceptions","title":"Excepciones no comprobadas o unchecked exceptions o <code>Runtime exceptions</code>","text":"<p>Excepci\u00f3n que ocurre en tiempo de ejecuci\u00f3n. El compilador no obliga a que se capture o se lance la excepci\u00f3n.</p> <p>Ejemplos: - NullPointerException - ArrayIndexOutOfBoundsException - ArithmeticException</p> <p></p>"},{"location":"java/excepciones.html#excepciones-mas-comunes","title":"Excepciones m\u00e1s comunes","text":""},{"location":"java/excepciones.html#excepciones-comprobadas","title":"Excepciones comprobadas","text":"Excepci\u00f3n Descripci\u00f3n <code>ClassNotFoundException</code> Indice que una clase no se ha encontrado. <code>NoSuchMethodException</code> Indica que el m\u00e9todo utilizado no existe <code>FileNotFoundException</code> Indica que el fichero no encontrado <code>ParseException</code> Error analizando un string"},{"location":"java/excepciones.html#excepciones-no-comprobadas","title":"Excepciones no comprobadas","text":"Excepci\u00f3n Descripci\u00f3n <code>NullPointerException</code> Indica que se ha intentado acceder a un objeto que no existe. <code>ArrayIndexOutOfBoundsException</code> Indica que se ha intentado acceder a un elemento de un array que no existe. <code>IllegalArgumentException</code> Sirve para indicar que un m\u00e9todo ha recibido parametros incorrectos. <code>StringIndexOutOfBoundsException</code> Ocurre cuando se intenta acceder a una posici\u00f3n de un String que no existe"},{"location":"java/excepciones.html#manejo-de-excepciones","title":"Manejo de excepciones","text":""},{"location":"java/excepciones.html#bloque-try-catch","title":"Bloque try-catch","text":"<p>La estructura <code>try-catch</code> se usa para manejar excepciones. En <code>try</code> se coloca el c\u00f3digo que puede lanzar una excepci\u00f3n. En <code>catch</code> se coloca el c\u00f3digo que se ejecuta cuando se lanza una excepci\u00f3n.</p> <pre><code>    try {\n        // C\u00f3digo que puede generar una excepci\u00f3n\n    } catch (ExcepcionTipo1 e) {\n        // Manejar la excepci\u00f3n de tipo 1\n    } catch (ExcepcionTipo2 e) {\n        // Manejar la excepci\u00f3n de tipo 2\n    }\n</code></pre> <p>En el c\u00f3digo de catch podemos hacer diferentes cosas: -  Imprimir un mensaje de error -  Relanzar la excepci\u00f3n -  Lanzar una nueva excepci\u00f3n -  Hacer alguna acci\u00f3n, depende del contexto</p> <p>En Java tambi\u00e9n existe el bloque <code>try-catch-finally</code>. El bloque <code>finally</code> se ejecuta siempre, independientemente de si se lanza una excepci\u00f3n o no.</p> <pre><code>    try {\n        // C\u00f3digo que puede generar una excepci\u00f3n\n    } catch (ExcepcionTipo1 e) {\n        // Manejar la excepci\u00f3n de tipo 1\n    } catch (ExcepcionTipo2 e) {\n        // Manejar la excepci\u00f3n de tipo 2\n    } finally {\n        // C\u00f3digo que se ejecuta siempre\n    }\n</code></pre>"},{"location":"java/excepciones.html#lanazamiento-de-excepciones","title":"Lanazamiento de excepciones","text":"<p>Para lanzar una excepci\u00f3n se usa la palabra clave <code>throw</code>. Se puede lanzar una excepci\u00f3n de cualquier tipo, pero es recomendable lanzar una excepci\u00f3n de un tipo existente.</p> <pre><code>    throw new ExcepcionTipo1();\n</code></pre> <p>Podemos hacer que el m\u00e9todo actual lance una excepci\u00f3n usando la palabra clave <code>throws</code>. En este caso, el m\u00e9todo actual no maneja la excepci\u00f3n, sino que la lanza al m\u00e9todo que lo llam\u00f3.</p> <pre><code>    public void metodo1() throws ExcepcionTipo1 {\n        // C\u00f3digo que puede generar una excepci\u00f3n\n    }\n</code></pre>"},{"location":"java/excepciones.html#excepciones-definidas-por-el-usuario","title":"Excepciones definidas por el usuario","text":"<p>Se pueden definir excepciones personalizadas. Para esto, se debe crear una clase que herede de la clase <code>Exception</code> o de la clase <code>RuntimeException</code>. La clase <code>Exception</code> se usa para crear excepciones comprobadas, mientras que la clase <code>RuntimeException</code> se usa para crear excepciones no comprobadas.</p> <pre><code>    public class MiExcepcion extends Exception {\n        // C\u00f3digo de la clase\n    }\n</code></pre> <pre><code>    public class MiExcepcion extends RuntimeException {\n        // C\u00f3digo de la clase\n    }\n</code></pre> <p>Crear nuestras excepciones ayuda a clasificar mejor los errores de la aplicaci\u00f3n. Se a\u00f1aden mensajes significativos que ayudan durante el proceso de desarrollo. Cuanto m\u00e1s especifica una excepci\u00f3n el control de los errores es m\u00e1s granular. </p> <p>Contructores de excepciones personalizadas: <pre><code>public class MiExcepcionPersonalizada extends Exception {\n    public MiExcepcionPersonalizada() {\n        super(\"Ocurri\u00f3 un error personalizado.\");\n    }\n\n    public MiExcepcionPersonalizada(String mensaje) {\n        super(mensaje);\n    }\n}\n</code></pre></p> <p>Otro ejemplo: <pre><code>public class MiExcepcionConAtributo extends Exception {\n    // Atributo personalizado\n    private int codigoError;\n\n    // Constructor que acepta un c\u00f3digo de error\n    public MiExcepcionConAtributo(int codigoError) {\n        this.codigoError = codigoError;\n    }\n\n    // Sobrescribe el m\u00e9todo getMessage() para incluir el c\u00f3digo de error en el mensaje\n    @Override\n    public String getMessage() {\n        return \"MiExcepcionConAtributo: C\u00f3digo de error \" + codigoError;\n    }\n}\n</code></pre></p> <p>Como se usa: <pre><code>public class Ejemplo {\n    public static void main(String[] args) {\n        try {\n            throw new MiExcepcionConAtributo(404);\n        } catch (MiExcepcionConAtributo e) {\n            System.out.println(e.getMessage()); \n            // Imprime: \"MiExcepcionConAtributo: C\u00f3digo de error 404\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"java/genericos.html","title":"Genericidad","text":""},{"location":"java/genericos.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/genericos.html#contenido","title":"Contenido","text":"<ul> <li>Que son los genericos?</li> <li>Clase gen\u00e9rica<ul> <li>Ejemplo de clase gen\u00e9rica con un tipo de par\u00e1metro</li> <li>Ejemplo de clase gen\u00e9rica con m\u00faltiples tipos de par\u00e1metros</li> </ul> </li> <li>Interfaces gen\u00e9ricas</li> <li>M\u00e9todos gen\u00e9ricos</li> <li>Restricciones de tipo gen\u00e9rico<ul> <li>Extends</li> <li>Super</li> <li>Multiple bounds</li> <li>Wildcards o comodines</li> </ul> </li> </ul>"},{"location":"java/genericos.html#que-son-los-genericos","title":"Que son los genericos?","text":"<p>Los tipos gen\u00e9ricos en Java son una forma de parametrizar clases, interfaces y m\u00e9todos.  Permiten que el c\u00f3digo sea reutilizable y m\u00e1s flexible. El uso de gen\u00e9ricos permite  escribir c\u00f3digo que puede funcionar con diferentes tipos de objetos. </p>"},{"location":"java/genericos.html#clase-generica","title":"Clase gen\u00e9rica","text":"<p>Podemos crear una clase gen\u00e9rica que pueda trabajar con diferentes tipos de objetos.  Veamos diferentes ejemplos para entender mejor c\u00f3mo funcionan los gen\u00e9ricos.</p>"},{"location":"java/genericos.html#ejemplo-de-clase-generica-con-un-tipo-de-parametro","title":"Ejemplo de clase gen\u00e9rica con un tipo de par\u00e1metro","text":"<pre><code>public class Box&lt;T&gt; {\n    private T content;\n\n    public Box(T t) {\n        this.content = t;\n    }\n\n    public T getContent() {\n        return content;\n    }\n\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(10);\n        Box&lt;String&gt; stringBox = new Box&lt;&gt;(\"Hello World\");\n\n        System.out.printf(\"Integer Value: %d\\n\", integerBox.getContent());\n        System.out.printf(\"String Value: %s\\n\", stringBox.getContent());\n    }\n}\n</code></pre> <p>La salida del programa anterior ser\u00e1:</p> <pre><code>Integer Value: 10\nString Value: Hello World\n</code></pre> <p>En el ejemplo anterior hemos creado una clase gen\u00e9rica llamada <code>Box</code> que puede almacenar cualquier tipo de objeto. La clase <code>Box</code> tiene un tipo de par\u00e1metro <code>T</code> que se utiliza para almacenar el tipo de objeto que se va a almacenar en la caja.</p> <p>El constructor de la clase <code>Box</code> toma un par\u00e1metro de tipo <code>T</code> que se utiliza para inicializar el campo <code>content</code>. El m\u00e9todo <code>getContent</code> devuelve el contenido de la caja que es de tipo <code>T</code>.</p> <p>En el m\u00e9todo <code>main</code> hemos creado dos instancias de la clase <code>Box</code>. La primera instancia de la clase <code>Box</code> almacena un objeto de tipo <code>Integer</code> y la segunda instancia de la clase <code>Box</code> almacena un objeto de tipo <code>String</code>.</p>"},{"location":"java/genericos.html#ejemplo-de-clase-generica-con-multiples-tipos-de-parametros","title":"Ejemplo de clase gen\u00e9rica con m\u00faltiples tipos de par\u00e1metros","text":"<pre><code>public class Pair&lt;T, U&gt; {\n    private T first;\n    private U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T getFirst() {\n        return first;\n    }\n\n    public U getSecond() {\n        return second;\n    }\n\n    public static void main(String[] args) {\n        Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, \"One\");\n        System.out.printf(\"First: %d, Second: %s\\n\", pair.getFirst(), pair.getSecond());\n\n        Pair&lt;String, String&gt; otherPair = new Pair&lt;&gt;(\"One\", \"Two\");\n        System.out.printf(\"First: %s, Second: %s\\n\", otherPair.getFirst(), otherPair.getSecond());\n    }\n}\n</code></pre> <p>La salida del programa anterior ser\u00e1:</p> <pre><code>First: 1, Second: One\nFirst: One, Second: Two\n</code></pre> <p>En el ejemplo anterior hemos creado una clase gen\u00e9rica llamada <code>Pair</code> que tiene dos tipos de par\u00e1metros <code>T</code> y <code>U</code>. La clase <code>Pair</code> tiene dos campos <code>first</code> y <code>second</code> que son de tipo <code>T</code> y <code>U</code> respectivamente. El constructor de la clase <code>Pair</code> toma dos par\u00e1metros de tipo <code>T</code> y <code>U</code> que se utilizan para inicializar los campos <code>first</code> y <code>second</code>.</p>"},{"location":"java/genericos.html#interfaces-genericas","title":"Interfaces gen\u00e9ricas","text":"<p>Podemos crear interfaces gen\u00e9ricas que puedan ser implementadas por diferentes tipos de objetos.</p> <pre><code>public interface Box&lt;T&gt; {\n    T getContent();\n}\n\npublic class BoxImpl&lt;T&gt; implements Box&lt;T&gt; {\n    private T content;\n\n    public BoxImpl(T t) {\n        this.content = t;\n    }\n\n    @Override\n    public T getContent() {\n        return content;\n    }\n\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new BoxImpl&lt;&gt;(10);\n        Box&lt;String&gt; stringBox = new BoxImpl&lt;&gt;(\"Hello World\");\n\n        System.out.printf(\"Integer Value: %d\\n\", integerBox.getContent());\n        System.out.printf(\"String Value: %s\\n\", stringBox.getContent());\n    }\n}\n</code></pre> <p>En el ejemplo anterior hemos creado una interfaz gen\u00e9rica llamada <code>Box</code> que tiene un tipo de par\u00e1metro <code>T</code>. La interfaz <code>Box</code> tiene un m\u00e9todo <code>getContent</code> que devuelve el contenido de la caja que es de tipo <code>T</code>.</p> <p>La clase <code>BoxImpl</code> implementa la interfaz <code>Box</code> y proporciona una implementaci\u00f3n del m\u00e9todo <code>getContent</code>. La clase <code>BoxImpl</code> tiene un tipo de par\u00e1metro <code>T</code> que se utiliza para inicializar el campo <code>content</code>. El m\u00e9todo <code>getContent</code> devuelve el contenido de la caja que es de tipo <code>T</code>.</p>"},{"location":"java/genericos.html#metodos-genericos","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Podemos crear m\u00e9todos gen\u00e9ricos que puedan ser invocados con parametros de diferentes tipos.</p> <pre><code>class Test {\n    public static &lt;T&gt; void genericDisplay(T element) {\n        System.out.println(element.getClass().getName() + \" = \" + element);\n    }\n\n    public static void main(String[] args) {\n        genericDisplay(11);\n        genericDisplay(\"Hello World\");\n        genericDisplay(1.0);\n    }\n}\n</code></pre> <p>La salida del programa anterior ser\u00e1:</p> <pre><code>java.lang.Integer = 11\njava.lang.String = Hello World\njava.lang.Double = 1.0\n</code></pre> <p>En el ejemplo anterior hemos creado un m\u00e9todo gen\u00e9rico llamado <code>genericDisplay</code> que puede ser invocado con par\u00e1metros de diferentes tipos. El m\u00e9todo imprime la clase y el valor del par\u00e1metro que se le pasa.</p>"},{"location":"java/genericos.html#restricciones-de-tipo-generico","title":"Restricciones de tipo gen\u00e9rico","text":""},{"location":"java/genericos.html#extends","title":"Extends","text":"<p>Podemos restringir el tipo de par\u00e1metro gen\u00e9rico a un cierto tipo o subtipo o interfaz utilizando la palabra clave <code>extends</code>.</p> <pre><code>public class Box&lt;T extends Number&gt; {\n    // ...\n} \n</code></pre> <p>En el ejemplo anterior hemos restringido el tipo de par\u00e1metro gen\u00e9rico <code>T</code> a un tipo <code>Number</code> o subtipo de <code>Number</code>. </p>"},{"location":"java/genericos.html#super","title":"Super","text":"<p>Esta restricci\u00f3n es opuesta a la restricci\u00f3n <code>extends</code>. Podemos restringir el tipo de par\u00e1metro gen\u00e9rico a un cierto tipo o super tipo de ese tipo.</p> <p><pre><code>public class Box&lt;T super Integer&gt; {\n    // ...\n} \n</code></pre> En la clase anterior hemos restringido el tipo de par\u00e1metro gen\u00e9rico <code>T</code> a un tipo <code>Integer</code> o super tipo de <code>Integer</code>, es decir, <code>Number</code> o <code>Object</code>.</p>"},{"location":"java/genericos.html#multiple-bounds","title":"Multiple bounds","text":"<p>Podemos restringir el tipo de par\u00e1metro gen\u00e9rico a m\u00faltiples tipos o interfaces utilizando la palabra clave <code>&amp;</code>.</p> <p><pre><code>public class Box&lt;T extends Number &amp; Comparable&gt; {\n    // ...\n} \n</code></pre> En el ejemplo anterior <code>T</code> debe ser un tipo <code>Number</code> o subtipo de <code>Number</code> y tambi\u00e9n debe implementar la interfaz <code>Comparable</code>.</p>"},{"location":"java/genericos.html#wildcards-o-comodines","title":"Wildcards o comodines","text":"<p>Los comodines se representan con el signo de interrogaci\u00f3n <code>?</code>. Sirven para representar con tipos gen\u00e9ricos desconocidos pero que son subtipos de un tipo concreto. Existen dos tipos: <code>? extends</code>(covariante) y <code>? super</code>(contravariante).</p> <p><pre><code>public void printList(List&lt;? extends Number&gt; list) {\n    // ...\n}\n</code></pre> El m\u00e9todo anterior puede ser invocado con una lista de cualquier tipo de n\u00famero o subtipo de n\u00famero.</p> <pre><code>public void printList(List&lt;? super Integer&gt; list) {\n    // ...\n}\n</code></pre> <p>El m\u00e9todo anterior puede ser invocado con una lista de cualquier tipo que sea super tipo de <code>Integer</code>, es decir, <code>Number</code> o <code>Object</code>.</p>"},{"location":"java/herencia.html","title":"Herencia","text":""},{"location":"java/herencia.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/herencia.html#contenido","title":"Contenido","text":"<ul> <li>Que es la herencia ?<ul> <li>Por que usar herencia ?</li> </ul> </li> <li>Tipos de herencia<ul> <li>Herencia simple o single inheritance</li> <li>Herencia multinivel o multilevel inheritance</li> <li>Herencia jer\u00e1rquica o hierarchical inheritance</li> <li>Herencia m\u00faltiple o multiple inheritance</li> </ul> </li> <li>Herencia en Java<ul> <li>Reglas de herencia en Java</li> </ul> </li> <li>Casting de objetos</li> </ul>"},{"location":"java/herencia.html#que-es-la-herencia","title":"Que es la herencia ?","text":"<p>La herencia es un concepto fundamental en la programaci\u00f3n orientada a objetos que  nos permite crear nuevas clases basadas en clases existentes. En Java, la herencia  es una caracter\u00edstica poderosa que facilita la reutilizaci\u00f3n de c\u00f3digo y la organizaci\u00f3n  de nuestros programas.</p> <p>La herencia en Java es un mecanismo que permite que una clase adquiera propiedades y  comportamientos (campos y m\u00e9todos) de otra clase. La clase padre(superclase) es la clase cuyas propiedades y comportamientos se heredan, y la clase hija(subclase) es la clase que hereda. </p>"},{"location":"java/herencia.html#por-que-usar-herencia","title":"Por que usar herencia ?","text":"<ul> <li>La herencia permite reutilizar c\u00f3digo. El c\u00f3digo de la superclase es com\u00fan a las subclases, por lo que no es necesario volver a escribirlo en cada subclase. Las clases hijas usan el c\u00f3digo de la clase padre heredando sus m\u00e9todos y atributos.</li> <li>La herencia permite extender el c\u00f3digo. Podemos agregar nuevos m\u00e9todos y atributos a la clase hija sin afectar a la clase padre.</li> <li>Podemos sobreescribir los m\u00e9todos de la clase padre en la clase hija para cambiar su comportamiento.</li> </ul>"},{"location":"java/herencia.html#tipos-de-herencia","title":"Tipos de herencia","text":""},{"location":"java/herencia.html#herencia-simple-o-single-inheritance","title":"Herencia simple o single inheritance","text":"<p> La <code>clase B</code> es una subclase de la <code>clase A</code> si la <code>clase B</code> extiende la <code>clase A</code>.  Una clase hija puede heredar de una sola clase padre. Es la herencia m\u00e1s com\u00fan.</p> <pre><code>class Padre {\n    // Atributos y m\u00e9todos de la clase padre\n}\n\nclass Hijo extends Padre {\n    // Atributos y m\u00e9todos de la clase hija\n}\n</code></pre>"},{"location":"java/herencia.html#herencia-multinivel-o-multilevel-inheritance","title":"Herencia multinivel o multilevel inheritance","text":"<p>Una clase puede heredar de una clase que a su vez hereda de otra clase. Es decir, una clase hija puede ser la clase padre de otra clase. </p> <p><pre><code>class A {\n    // Atributos y m\u00e9todos de la clase A\n}\nclass B extends A {\n    // Atributos y m\u00e9todos de la clase B\n}\nclass C extends B {\n    // Atributos y m\u00e9todos de la clase C\n}\n</code></pre> La <code>clase C</code> hereda de la <code>clase B</code> que a su vez hereda de la <code>clase A</code>. La <code>clase C</code> hereda todos los atributos y m\u00e9todos de la <code>clase B</code> y la <code>clase A</code>.</p>"},{"location":"java/herencia.html#herencia-jerarquica-o-hierarchical-inheritance","title":"Herencia jer\u00e1rquica o hierarchical inheritance","text":"<p>Una clase puede tener m\u00e1s de una subclase. Es decir, una clase padre puede tener m\u00e1s de una clase hija. </p> <p><pre><code>class A {\n    // Atributos y m\u00e9todos de la clase A\n}\nclass B extends A {\n    // Atributos y m\u00e9todos de la clase B\n}\nclass C extends A {\n    // Atributos y m\u00e9todos de la clase C\n}\n</code></pre> La <code>clase A</code> es la clase padre de la <code>clase B</code> y la <code>clase C</code>. La <code>clase B</code> y la <code>clase C</code> heredan todos los atributos y m\u00e9todos de la <code>clase A</code>.</p>"},{"location":"java/herencia.html#herencia-multiple-o-multiple-inheritance","title":"Herencia m\u00faltiple o multiple inheritance","text":"<p>Una clase puede heredar de m\u00e1s de una clase. Es decir, una clase hija puede tener m\u00e1s de una clase padre. En Java NO se permite la herencia multiple. Se puede simular usando interfaces. </p> <p><pre><code>interface A {\n}\n\ninterface B {\n}\n\nclass C implements A, B {\n}\n</code></pre> Se puede usar la herencia multiple en lenguajes como C++, pero no en Java.</p>"},{"location":"java/herencia.html#herencia-en-java","title":"Herencia en Java","text":"<p>En Java, la herencia se implementa usando la palabra clave <code>extends</code>. La sintaxis es la siguiente:</p> <pre><code>class Animal {\n    // Atributos y m\u00e9todos de la clase Animal\n}\n\nclass Perro extends Animal {\n    // Atributos y m\u00e9todos de la clase Perro\n}\n</code></pre> <p>La <code>clase Perro</code> hereda de la <code>clase Animal</code>. La <code>clase Animal</code> es la clase padre de la <code>clase Perro</code>. La <code>clase Perro</code> es la clase hija de la <code>clase Animal</code>. Un objeto <code>Perro</code> es tambi\u00e9n un objeto <code>Animal</code>.</p>"},{"location":"java/herencia.html#reglas-de-herencia-en-java","title":"Reglas de herencia en Java","text":"<ul> <li>La herencia multiple no est\u00e1 permitida en Java. Una clase puede heredar de una sola clase.</li> <li>La herencia ciclica no est\u00e1 permitida en Java. Una clase no puede heredar de si misma.</li> <li>Los atributos y m\u00e9todos privados no se heredan. </li> <li>Los constructores no se heredan. Sin embargo, el constructor de la clase padre se invoca desde el constructor de la clase hija usando la palabra clave <code>super()</code>.</li> </ul> <pre><code>// Clase padre\nclass Figura {\n    public double calcularArea() {\n        return 0.0;\n    }\n}\n\n// Clase hija\nclass Circulo extends Figura {\n    private double radio;\n\n    public Circulo(double radio) {\n        this.radio = radio;\n    }\n\n    public double getRadio() {\n        return radio;\n    }\n\n    @Override\n    public double calcularArea() {\n        return Math.PI * radio * radio;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Circulo miCirculo = new Circulo(5.0);\n\n        // Podemos llamar al m\u00e9todo heredado calcularArea() desde la subclase\n        double areaDelCirculo = miCirculo.calcularArea();\n\n        // Tambi\u00e9n podemos acceder a los m\u00e9todos espec\u00edficos de la subclase\n        double radioDelCirculo = miCirculo.obtenerRadio();\n\n        System.out.println(\"\u00c1rea del c\u00edrculo: \" + areaDelCirculo);\n        System.out.println(\"Radio del c\u00edrculo: \" + radioDelCirculo);\n    }\n}\n</code></pre>"},{"location":"java/herencia.html#sobreescritura-de-metodos","title":"Sobreescritura de m\u00e9todos","text":"<p>La sobreescritura de m\u00e9todos es una caracter\u00edstica de la programaci\u00f3n orientada a objetos que nos permite cambiar la implementaci\u00f3n de un m\u00e9todo en la clase hija que ya existe en la clase padre. La sobreescritura de m\u00e9todos se usa para lograr el polimorfismo.</p> <p>La clase hija sobreescribe o redefine el m\u00e9todo de la clase padre. La clase hija puede sobreescribir un m\u00e9todo de la clase padre si el m\u00e9todo de la clase padre es <code>public</code> o <code>protected</code>. No se puede sobreescribir un m\u00e9todo de la clase padre si el m\u00e9todo de la clase padre es <code>private</code>. Es buena pr\u00e1ctica usar la anotaci\u00f3n <code>@Override</code> para indicar que el m\u00e9todo est\u00e1 sobrescrito.</p> <pre><code>class Animal {\n  void speak() {\n    System.out.println(\"El animal habla\");\n  }\n}\n\nclass Cat extends Animal {\n  @Override\n  void speak() {\n    System.out.println(\"El gato ma\u00falla\");\n  }\n}\n</code></pre>"},{"location":"java/herencia.html#this-y-super","title":"<code>this</code> y <code>super</code>","text":"<p>La palabra clave <code>this</code> se usa para hacer referencia a la instancia actual de la clase. La palabra clave <code>super</code> se usa para hacer referencia a la instancia de la clase padre. </p> <pre><code>class Parent {\n  int value;\n\n  Parent(int value) {\n    this.value = value;\n  }\n\n  void display() {\n    System.out.println(\"Valor del padre: \" + value);\n  }\n}\n\nclass Child extends Parent {\n  int value;\n\n  Child(int parentValue, int childValue) {\n    super(parentValue);\n    this.value = childValue;\n  }\n\n  void display() {\n    System.out.println(\"Valor del hijo: \" + value);\n    super.display(); // m\u00e9todo display del adre\n  }\n}\n</code></pre> <p>Con <code>super()</code> podemos llamar al constructor de la clase padre desde el constructor de la clase hija.</p>"},{"location":"java/herencia.html#casting-de-objetos","title":"Casting de objetos","text":"<p>El casting de objetos es la conversi\u00f3n de un tipo de objeto a otro. En Java, el casting de objetos se puede dividir en dos tipos: - Upcasting: convertir un objeto de una subclase a un objeto de la superclase. Se puede hacer de forma impl\u00edcita o expl\u00edcita. <pre><code>Parent p = new Child(); \n</code></pre> En el ejemplo anterior <code>p</code> es una referencia de la clase padre que apunta a un objeto de la clase hija. La referencia <code>p</code> puede acceder a los m\u00e9todos y atributos de la clase padre y solamente los m\u00e9todos sobrescritos de la clase hija.</p> <ul> <li>Downcasting: convertir un objeto de una superclase a un objeto de la subclase. No puede ser impl\u00edcito. Provoca una excepci\u00f3n <code>ClassCastException</code> si no se usa <code>instanceof</code>. <pre><code>Child c = (Child) p;\n</code></pre> En el c\u00f3digo anterior <code>p</code> es una referencia a la clase padre que apunta a un objeto de la clase hija. Estamos convirtiendo el objeto de la clase padre en un objeto de la clase hija. La referencia <code>c</code> puede acceder a todos los m\u00e9todos y atributos de la clase padre y de la clase hija.</li> </ul> <pre><code>class Parent {\n    public void show() {\n        System.out.println(\"Parent show method is called\");\n    }\n} \n\nclass Child extends Parent {\n    @Override\n    public void show() {\n        System.out.println(\"Child show method is called\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Upcasting\n        Parent parent = new Child();\n        parent.show(); // Child show method is called\n\n        // Downcasting\n        Child child = (Child) parent;\n        child.show(); // Child show method is called\n    }\n}\n</code></pre>"},{"location":"java/interfaces.html","title":"Interfaces","text":""},{"location":"java/interfaces.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/interfaces.html#contenido","title":"Contenido","text":"<ul> <li>Que es una interfaz ?</li> <li>Usos y reglas de las interfaces</li> <li>Ejemplo</li> </ul>"},{"location":"java/interfaces.html#que-es-una-interfaz","title":"Que es una interfaz ?","text":"<p>Las interfaces en Java son un mecanismo para conseguir m\u00e1s nivel de abstracci\u00f3n. Una interfaz es una colecci\u00f3n de m\u00e9todos abstractosm no pueden tener implementaciones.  Define las firmas de los m\u00e9todos, es  decir, el nombre, los par\u00e1metros y el tipo de retorno, pero no su implementaci\u00f3n. </p> <p>Para crear una interfaz, usamos la palabra clave <code>interface</code> en lugar de <code>class</code>. </p> <pre><code>interface InterfaceName {\n    // Constantes\n    final int CONSTANT = 100;\n    // M\u00e9todos abstractos por defecto\n    int method1();\n    double methood2();\n}\n</code></pre>"},{"location":"java/interfaces.html#usos-y-reglas-de-las-interfaces","title":"Usos y reglas de las interfaces","text":"<ul> <li>Las interfaces se usan para lograr la abstracci\u00f3n.</li> <li>Las interfaces se usan para lograr la funcionalidad de m\u00faltiples herencias.</li> <li>Una clase puede implementar m\u00e1s de una interfaz.</li> <li>Una clase puede heredar de una clase e implementar una o m\u00e1s interfaces.</li> <li>Las variables declaradas en una interfaz son por defecto <code>public</code>, <code>static</code> y <code>final</code>.</li> <li>No se puede crear una instancia de una interfaz pero se puede crear una referencia de una interfaz.</li> <li>Una interfaz puede extender otra interfaz.</li> <li>Una clase que implementa una interfaz debe implementar todos sus m\u00e9todos.</li> <li>No hay constructores en una interfaz.</li> <li>No hay m\u00e9todo <code>main()</code> en una interfaz.</li> <li>No se puede declarar m\u00e9todos como  <code>private</code>, <code>static</code> o <code>final</code> en una interfaz.</li> </ul>"},{"location":"java/interfaces.html#ejemplo","title":"Ejemplo","text":"<pre><code>public interface Vehicle {\n    // Constantes\n    final int MAX_SPEED = 100;\n    // M\u00e9todos abstractos\n    void changeGear(int a);\n    void speedUp(int a);\n    void applyBrakes(int a);\n}\n\npublic class Car implements Vehicle {\n    int speed;\n    int gear;\n\n    // Implementaci\u00f3n de los m\u00e9todos abstractos\n    @Override\n    public void changeGear(int newGear) {\n        // ...\n    }\n\n    @Override\n    public void speedUp(int increment) {\n        // ...\n    }\n\n    @Override\n    public void applyBrakes(int decrement) {\n        // ...\n    }\n}\n\npublic class Motocycle implements Vehicle {\n    @Override\n    public void changeGear(int newGear) {\n        // ...\n    }\n\n    @Override\n    public void speedUp(int increment) {\n        // ...\n    }\n\n    @Override\n    public void applyBrakes(int decrement) {\n        // ...\n    }\n}\n</code></pre> <p>Podemos crear una referencia de una interfaz y usarla para referir a un objeto de una clase que implementa la interfaz. Por ejemplo:</p> <pre><code>public class Test {\n    public static void main(String[] args) {\n        Vehicle car = new Car();\n        Vehicle motocycle = new Motocycle();\n\n        car.changeGear(2);\n        car.speedUp(3);\n        motocycle.changeGear(1);\n        motocycle.speedUp(4);\n    }\n}\n</code></pre>"},{"location":"java/reflexion.html","title":"Reflexi\u00f3n","text":""},{"location":"java/reflexion.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/reflexion.html#contenido","title":"Contenido","text":"<ul> <li>Que es la reflexi\u00f3n ?</li> <li>Para que sirve la reflexi\u00f3n ?</li> <li>M\u00e9todos b\u00e1sicos de la API de reflexi\u00f3n<ul> <li>Obtener una clase</li> <li>Obtener los constructores de una clase</li> <li>Obtener los m\u00e9todos de una clase</li> <li>Obtener informaci\u00f3n sobre los m\u00e9todos de una clase</li> <li>Obtener los campos de una clase</li> <li>Obtener la superclase de una clase</li> <li>Obtener interfaces implementadas por una clase</li> <li>Obtener los modificadores de acceso de una clase</li> <li>Obtener las anotaciones de una clase</li> <li>Invocar un m\u00e9todo</li> </ul> </li> <li>Enlaces de inter\u00e9s</li> </ul>"},{"location":"java/reflexion.html#que-es-la-reflexion","title":"Que es la reflexi\u00f3n ?","text":"<p>La reflexi\u00f3n (en ingl\u00e9s reflection) en Java es una API que permite a los programas obtener informaci\u00f3n sobre el tipo y la estructura de los objetos en tiempo de ejecuci\u00f3n. La reflexi\u00f3n permite que los programas puedan utilizar esta informaci\u00f3n y acceder a los objetos sobre los que se est\u00e1 ejecutando la aplicaci\u00f3n. Permite leer  los metadatos de las clases, interfaces, campos y m\u00e9todos de clases cargadas en memoria. Tambi\u00e9n permite instanciar clases, invocar m\u00e9todos, obtener y cambiar el valor de los campos de una clase.</p>"},{"location":"java/reflexion.html#para-que-sirve-la-reflexion","title":"Para que sirve la reflexi\u00f3n ?","text":"<p>La API de reflexi\u00f3n se utiliza en frameworks de inyecci\u00f3n de dependencias, frameworks de persistencia, frameworks de testing, frameworks de mapeo objeto-relacional, frameworks de serializaci\u00f3n, etc.</p>"},{"location":"java/reflexion.html#metodos-basicos-de-la-api-de-reflexion","title":"M\u00e9todos b\u00e1sicos de la API de reflexi\u00f3n","text":""},{"location":"java/reflexion.html#obtener-una-clase","title":"Obtener una clase","text":"<p>En reflexi\u00f3n, las clases se guardan en objetos de tipo Class. Hay varias formas de obtener la clase:</p> <pre><code>Class&lt;?&gt; c1 = Class.forName(\"com.example.MyClass\");\nClass&lt;MyClass&gt; c2 = MyClass.class; // Podemos especificar que tipo de clase esperamos obtener\nClass&lt;?&gt; c3 = obj.getClass();\n</code></pre>"},{"location":"java/reflexion.html#obtener-los-constructores-de-una-clase","title":"Obtener los constructores de una clase","text":"<pre><code>Class&lt;?&gt; extractClass = Class.forName(\"models.Employee\");\nConstructor&lt;?&gt;[] constructors = extractClass.getConstructors();\n\nfor (Constructor&lt;?&gt; constructor : constructors) {\n    System.out.println(constructor.getName());\n}\n</code></pre>"},{"location":"java/reflexion.html#obtener-los-metodos-de-una-clase","title":"Obtener los m\u00e9todos de una clase","text":"<p>El m\u00e9todo <code>getMethods()</code> devuelve todos los m\u00e9todos p\u00fablicos de la clase y de sus superclases. Para obtener todos los m\u00e9todos de la clase, incluyendo los privados, se utiliza el m\u00e9todo <code>getDeclaredMethods()</code>.</p> <pre><code>Class&lt;Persona&gt; extractClass = Persona.class;\nMethod[] methods = extractClass.getDeclaredMethods();\nSystem.out.println(\"M\u00e9todos de la clase Persona: \" + Arrays.toString(methods));\n</code></pre>"},{"location":"java/reflexion.html#obtener-informacion-sobre-los-metodos-de-una-clase","title":"Obtener informaci\u00f3n sobre los m\u00e9todos de una clase","text":"<pre><code>Class&lt;Persona&gt; extractClass = Persona.class;\nMethod[] methods = extractClass.getDeclaredMethods();\nfor (Method method : methods) {\n    System.out.println(\"Nombre del m\u00e9todo: \" + method.getName());\n    System.out.println(\"Tipo de retorno: \" + method.getReturnType());\n    System.out.println(\"Par\u00e1metros: \" + Arrays.toString(method.getParameterTypes()));\n    System.out.println(\"Excepciones: \" + Arrays.toString(method.getExceptionTypes()));\n    System.out.println(\"Modificadores: \" + Modifier.toString(method.getModifiers()));\n}\n</code></pre>"},{"location":"java/reflexion.html#obtener-los-campos-de-una-clase","title":"Obtener los campos de una clase","text":"<p>El m\u00e9todo <code>getFields()</code> devuelve todos los campos p\u00fablicos de la clase y de sus superclases. Para obtener todos los campos de la clase, incluyendo los privados, se utiliza el m\u00e9todo <code>getDeclaredFields()</code>.</p> <pre><code>Class&lt;Persona&gt; extractClass = Persona.class;\nField[] classFields = extractClass.getDeclaredFields();\nField[] allFields = extractClass.getFields(); // Incluye los campos de las superclases\n</code></pre>"},{"location":"java/reflexion.html#obtener-la-superclase-de-una-clase","title":"Obtener la superclase de una clase","text":"<pre><code>Class&lt;Persona&gt; myClass = Persona.class;\nClass&lt;? super Persona&gt; superClass = myClass.getSuperclass();\n</code></pre>"},{"location":"java/reflexion.html#obtener-interfaces-implementadas-por-una-clase","title":"Obtener interfaces implementadas por una clase","text":"<pre><code>Class&lt;Persona&gt; myClass = Persona.class;\nClass&lt;?&gt;[] interfaces = myClass.getInterfaces();\n</code></pre>"},{"location":"java/reflexion.html#obtener-los-modificadores-de-acceso-de-una-clase","title":"Obtener los modificadores de acceso de una clase","text":"<pre><code>int modifiers = Persona.class.getModifiers();\nSystem.out.println(\"Modificadores de acceso de la clase Persona: \" + Modifier.toString(modifiers));\n</code></pre>"},{"location":"java/reflexion.html#obtener-las-anotaciones-de-una-clase","title":"Obtener las anotaciones de una clase","text":"<pre><code>Class&lt;Persona&gt; myClass = Persona.class;\nAnnotation[] annotations = myClass.getAnnotations();\nSystem.out.println(\"Anotaciones de la clase Persona: \" + Arrays.toString(annotations));\n</code></pre>"},{"location":"java/reflexion.html#invocar-un-metodo","title":"Invocar un m\u00e9todo","text":"<pre><code>Persona persona = new Persona(\"Erik\", \"Avagyan\");\nClass&lt;Persona&gt; myClass = Persona.class;\nMethod setAge = myClass.getDeclaredMethod(\"setAge\", int.class);\nsetAge.setAccessible(true); // si el m\u00e9todo es privado\nsetAge.invoke(persona, 25);\nsetAge.setAccessible(false);\n</code></pre>"},{"location":"java/reflexion.html#enlaces-de-interes","title":"Enlaces de inter\u00e9s","text":"<ul> <li>Documentaci\u00f3n oficial de la API de reflexi\u00f3n</li> <li>Tutorial completo de reflexi\u00f3n en Java</li> </ul>"},{"location":"java/sobreescritura.html","title":"Sobreescritura de m\u00e9todos","text":""},{"location":"java/sobreescritura.html#autor-erik-avagyan","title":"Autor: Erik Avagyan","text":""},{"location":"java/sobreescritura.html#contenido","title":"Contenido","text":"<ul> <li>Sobreescritura de m\u00e9todos</li> <li>Ejemplo</li> <li>Reglas para la sobrescritura de m\u00e9todos</li> <li>Sobrescritura VS Sobrecarga</li> </ul>"},{"location":"java/sobreescritura.html#sobreescritura-de-metodos_1","title":"Sobreescritura de m\u00e9todos","text":"<p>La sobreescritura de m\u00e9todos o override es una caracter\u00edstica de la programaci\u00f3n orientada a objetos que permite a una subclase proporcionar una implementaci\u00f3n espec\u00edfica de un m\u00e9todo que ya est\u00e1 proporcionado por una de sus superclases o clases de interfaces. El m\u00e9todo que sobrescribe debe tener el mismo nombre, mismos par\u00e1metros y el mismo tipo de retorno que el m\u00e9todo que sobrescribe. </p> <p>Gracias a la sobrescritura de m\u00e9todos es posible usar el polimorfismo que explicaremos m\u00e1s adelante.</p>"},{"location":"java/sobreescritura.html#ejemplo","title":"Ejemplo","text":"<p><pre><code>class Parent {\n    void show() { System.out.println(\"Parent's show()\"); }\n}\n\nclass Child extends Parent {\n    // Sobrescribe el m\u00e9todo show() de la clase padre\n    @Override void show()\n    {\n        System.out.println(\"Child's show()\");\n    }\n}\n</code></pre> Si ejecutamos el siguiente c\u00f3digo: <pre><code>    Parent obj1 = new Parent();\n    obj1.show();\n\n    Parent obj2 = new Child();\n    obj2.show();\n</code></pre></p> <p>Obtendremos la siguiente salida: <pre><code>Parent's show()\nChild's show()\n</code></pre></p>"},{"location":"java/sobreescritura.html#reglas-para-la-sobrescritura-de-metodos","title":"Reglas para la sobrescritura de m\u00e9todos","text":"<ul> <li> <p>Un m\u00e9todo sobrescrito puede tener diferente nivel de acceso pero no un nivel de acceso m\u00e1s restrictivo que el m\u00e9todo que sobrescribe. Por ejemplo, si el m\u00e9todo de la superclase es declarado protected, el m\u00e9todo sobrescrito en la subclase puede ser public, pero no private.</p> </li> <li> <p>Los m\u00e9todos declarados como final o static no pueden ser sobrescritos.</p> </li> <li> <p>Los m\u00e9todos privados no se pueden sobrescribir, ya que no son visibles fuera de la clase.</p> </li> <li> <p>El tipo devuelto de un m\u00e9todo sobrescrito puede ser un subtipo del tipo devuelto por el m\u00e9todo de la superclase.</p> </li> <li> <p>Para invocar el m\u00e9todo de la superclase, se utiliza la palabra clave super. Por ejemplo, <code>super.show()</code> invocar\u00e1 el m\u00e9todo show() de la superclase.</p> </li> </ul>"},{"location":"java/sobreescritura.html#sobrescritura-vs-sobrecarga","title":"Sobrescritura VS Sobrecarga","text":"<p>La sobrecarga de m\u00e9todos es una caracter\u00edstica de la programaci\u00f3n orientada a objetos que permite a una clase tener m\u00e1s de un m\u00e9todo con el mismo nombre, siempre que la lista de argumentos sea diferente. Esto se conoce como sobrecarga de m\u00e9todos. Un uso de la sobrecarga de m\u00e9todos es tener varios constructores que aceptan diferentes conjuntos de argumentos.</p> <pre><code>public class Suma {\n    public int suma(int x, int y) {\n        return x + y;\n    }\n\n    public int suma(int x, int y, int z) {\n        return x + y + z;\n    }\n\n    public double suma(double x, double y) {\n        return x + y;\n    }\n}\n</code></pre> <p>La sobrescritura de m\u00e9todos es una caracter\u00edstica de la programaci\u00f3n orientada a objetos que permite a una subclase proporcionar una implementaci\u00f3n espec\u00edfica de un m\u00e9todo que ya est\u00e1 proporcionado por una de sus superclases o clases de interfaces. El m\u00e9todo que sobrescribe debe tener el mismo nombre, mismos par\u00e1metros y el mismo tipo de retorno que el m\u00e9todo que sobrescribe.</p>"}]}